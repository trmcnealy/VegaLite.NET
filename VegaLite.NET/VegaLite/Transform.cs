using System.Collections.Generic;

using Newtonsoft.Json;

namespace VegaLite
{
    public class Transform
    {
        /// <summary>
        /// Array of objects that define fields to aggregate.
        /// </summary>
        [JsonProperty("aggregate", NullValueHandling = NullValueHandling.Ignore)]
        public List<AggregatedFieldDef> Aggregate { get; set; }

        /// <summary>
        /// The data fields to group by. If not specified, a single group containing all data objects
        /// will be used.
        ///
        /// An optional array of fields by which to group the values.
        /// Imputation will then be performed on a per-group basis.
        ///
        /// The data fields for partitioning the data objects into separate groups. If unspecified,
        /// all data points will be in a single group.
        ///
        /// The data fields to group by.
        ///
        /// The data fields for partitioning the data objects into separate windows. If unspecified,
        /// all data points will be in a single window.
        ///
        /// The optional data fields to group by. If not specified, a single group containing all
        /// data objects will be used.
        /// </summary>
        [JsonProperty("groupby", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> Groupby { get; set; }

        /// <summary>
        /// The output fields at which to write the start and end bin values.
        ///
        /// The field for storing the computed formula value.
        ///
        /// The output fields for the sample value and corresponding density estimate.
        ///
        /// __Default value:__ `["value", "density"]`
        ///
        /// The output field names for extracted array values.
        ///
        /// __Default value:__ The field name of the corresponding array field
        ///
        /// The output field names for the key and value properties produced by the fold transform.
        /// __Default value:__ `["key", "value"]`
        ///
        /// The output field names for the smoothed points generated by the loess transform.
        ///
        /// __Default value:__ The field names of the input x and y values.
        ///
        /// The output fields on which to store the looked up data values.
        ///
        /// For data lookups, this property may be left blank if `from.fields`
        /// has been specified (those field names will be used); if `from.fields`
        /// has not been specified, `as` must be a string.
        ///
        /// For selection lookups, this property is optional: if unspecified,
        /// looked up values will be stored under a property named for the selection;
        /// and if specified, it must correspond to `from.fields`.
        ///
        /// The output field names for the probability and quantile values.
        ///
        /// __Default value:__ `["prob", "value"]`
        ///
        /// The output field names for the smoothed points generated by the regression transform.
        ///
        /// __Default value:__ The field names of the input x and y values.
        ///
        /// The output field to write the timeUnit value.
        ///
        /// Output field names. This can be either a string or an array of strings with two elements
        /// denoting the name for the fields for stack start and stack end respectively.
        /// If a single string(e.g., `"val"`) is provided, the end field will be `"val_end"`.
        /// </summary>
        [JsonProperty("as", NullValueHandling = NullValueHandling.Ignore)]
        public Text? As { get; set; }

        /// <summary>
        /// An object indicating bin properties, or simply `true` for using default bin parameters.
        /// </summary>
        [JsonProperty("bin", NullValueHandling = NullValueHandling.Ignore)]
        public TransformBin? Bin { get; set; }

        /// <summary>
        /// The data field to bin.
        ///
        /// The data field to apply time unit.
        /// </summary>
        [JsonProperty("field", NullValueHandling = NullValueHandling.Ignore)]
        public string Field { get; set; }

        /// <summary>
        /// A [expression](https://vega.github.io/vega-lite/docs/types.html#expression) string. Use
        /// the variable `datum` to refer to the current data object.
        /// </summary>
        [JsonProperty("calculate", NullValueHandling = NullValueHandling.Ignore)]
        public string Calculate { get; set; }

        /// <summary>
        /// The bandwidth (standard deviation) of the Gaussian kernel. If unspecified or set to zero,
        /// the bandwidth value is automatically estimated from the input data using Scott’s rule.
        ///
        /// A bandwidth parameter in the range `[0, 1]` that determines the amount of smoothing.
        ///
        /// __Default value:__ `0.3`
        /// </summary>
        [JsonProperty("bandwidth", NullValueHandling = NullValueHandling.Ignore)]
        public double? Bandwidth { get; set; }

        /// <summary>
        /// A boolean flag indicating if the output values should be probability estimates (false) or
        /// smoothed counts (true).
        ///
        /// __Default value:__ `false`
        /// </summary>
        [JsonProperty("counts", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Counts { get; set; }

        /// <summary>
        /// A boolean flag indicating whether to produce density estimates (false) or cumulative
        /// density estimates (true).
        ///
        /// __Default value:__ `false`
        /// </summary>
        [JsonProperty("cumulative", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Cumulative { get; set; }

        /// <summary>
        /// The data field for which to perform density estimation.
        /// </summary>
        [JsonProperty("density", NullValueHandling = NullValueHandling.Ignore)]
        public string Density { get; set; }

        /// <summary>
        /// A [min, max] domain from which to sample the distribution. If unspecified, the extent
        /// will be determined by the observed minimum and maximum values of the density value
        /// field.
        ///
        /// A [min, max] domain over the independent (x) field for the starting and ending points of
        /// the generated trend line.
        /// </summary>
        [JsonProperty("extent", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> Extent { get; set; }

        /// <summary>
        /// The maximum number of samples to take along the extent domain for plotting the density.
        ///
        /// __Default value:__ `200`
        /// </summary>
        [JsonProperty("maxsteps", NullValueHandling = NullValueHandling.Ignore)]
        public double? Maxsteps { get; set; }

        /// <summary>
        /// The minimum number of samples to take along the extent domain for plotting the density.
        ///
        /// __Default value:__ `25`
        /// </summary>
        [JsonProperty("minsteps", NullValueHandling = NullValueHandling.Ignore)]
        public double? Minsteps { get; set; }

        /// <summary>
        /// The exact number of samples to take along the extent domain for plotting the density. If
        /// specified, overrides both minsteps and maxsteps to set an exact number of uniform
        /// samples. Potentially useful in conjunction with a fixed extent to ensure consistent
        /// sample points for stacked densities.
        /// </summary>
        [JsonProperty("steps", NullValueHandling = NullValueHandling.Ignore)]
        public double? Steps { get; set; }

        /// <summary>
        /// The `filter` property must be one of the predicate definitions:
        ///
        /// 1) an [expression](https://vega.github.io/vega-lite/docs/types.html#expression) string,
        /// where `datum` can be used to refer to the current data object
        ///
        /// 2) one of the field predicates:
        /// [`equal`](https://vega.github.io/vega-lite/docs/filter.html#equal-predicate),
        /// [`lt`](https://vega.github.io/vega-lite/docs/filter.html#lt-predicate),
        /// [`lte`](https://vega.github.io/vega-lite/docs/filter.html#lte-predicate),
        /// [`gt`](https://vega.github.io/vega-lite/docs/filter.html#gt-predicate),
        /// [`gte`](https://vega.github.io/vega-lite/docs/filter.html#gte-predicate),
        /// [`range`](https://vega.github.io/vega-lite/docs/filter.html#range-predicate),
        /// [`oneOf`](https://vega.github.io/vega-lite/docs/filter.html#one-of-predicate),
        /// or [`valid`](https://vega.github.io/vega-lite/docs/filter.html#valid-predicate),
        ///
        /// 3) a [selection
        /// predicate](https://vega.github.io/vega-lite/docs/filter.html#selection-predicate)
        ///
        /// 4) a logical operand that combines (1), (2), or (3).
        /// </summary>
        [JsonProperty("filter", NullValueHandling = NullValueHandling.Ignore)]
        public LogicalOperandPredicate? Filter { get; set; }

        /// <summary>
        /// An array of one or more data fields containing arrays to flatten.
        /// If multiple fields are specified, their array values should have a parallel structure,
        /// ideally with the same length.
        /// If the lengths of parallel arrays do not match,
        /// the longest array will be used with `null` values added for missing entries.
        /// </summary>
        [JsonProperty("flatten", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> Flatten { get; set; }

        /// <summary>
        /// An array of data fields indicating the properties to fold.
        /// </summary>
        [JsonProperty("fold", NullValueHandling = NullValueHandling.Ignore)]
        public List<string> Fold { get; set; }

        /// <summary>
        /// A frame specification as a two-element array used to control the window over which the
        /// specified method is applied. The array entries should either be a number indicating the
        /// offset from the current data object, or null to indicate unbounded rows preceding or
        /// following the current data object. For example, the value `[-5, 5]` indicates that the
        /// window should include five objects preceding and five objects following the current
        /// object.
        ///
        /// __Default value:__:  `[null, null]` indicating that the window includes all objects.
        ///
        /// A frame specification as a two-element array indicating how the sliding window should
        /// proceed. The array entries should either be a number indicating the offset from the
        /// current data object, or null to indicate unbounded rows preceding or following the
        /// current data object. The default value is `[null, 0]`, indicating that the sliding window
        /// includes the current object and all preceding objects. The value `[-5, 5]` indicates that
        /// the window should include five objects preceding and five objects following the current
        /// object. Finally, `[null, null]` indicates that the window frame should always include all
        /// data objects. If you this frame and want to assign the same value to add objects, you can
        /// use the simpler [join aggregate
        /// transform](https://vega.github.io/vega-lite/docs/joinaggregate.html). The only operators
        /// affected are the aggregation operations and the `first_value`, `last_value`, and
        /// `nth_value` window operations. The other window operations are not affected by this.
        ///
        /// __Default value:__:  `[null, 0]` (includes the current object and all preceding objects)
        /// </summary>
        [JsonProperty("frame", NullValueHandling = NullValueHandling.Ignore)]
        public List<double?> Frame { get; set; }

        /// <summary>
        /// The data field for which the missing values should be imputed.
        /// </summary>
        [JsonProperty("impute", NullValueHandling = NullValueHandling.Ignore)]
        public string Impute { get; set; }

        /// <summary>
        /// A key field that uniquely identifies data objects within a group.
        /// Missing key values (those occurring in the data but not in the current group) will be
        /// imputed.
        /// </summary>
        [JsonProperty("key", NullValueHandling = NullValueHandling.Ignore)]
        public string Key { get; set; }

        /// <summary>
        /// Defines the key values that should be considered for imputation.
        /// An array of key values or an object defining a [number
        /// sequence](https://vega.github.io/vega-lite/docs/impute.html#sequence-def).
        ///
        /// If provided, this will be used in addition to the key values observed within the input
        /// data. If not provided, the values will be derived from all unique values of the `key`
        /// field. For `impute` in `encoding`, the key field is the x-field if the y-field is
        /// imputed, or vice versa.
        ///
        /// If there is no impute grouping, this property _must_ be specified.
        /// </summary>
        [JsonProperty("keyvals", NullValueHandling = NullValueHandling.Ignore)]
        public Keyvals? Keyvals { get; set; }

        /// <summary>
        /// The imputation method to use for the field value of imputed data objects.
        /// One of `"value"`, `"mean"`, `"median"`, `"max"` or `"min"`.
        ///
        /// __Default value:__  `"value"`
        ///
        /// The functional form of the regression model. One of `"linear"`, `"log"`, `"exp"`,
        /// `"pow"`, `"quad"`, or `"poly"`.
        ///
        /// __Default value:__ `"linear"`
        /// </summary>
        [JsonProperty("method", NullValueHandling = NullValueHandling.Ignore)]
        public TransformMethod? Method { get; set; }

        /// <summary>
        /// The field value to use when the imputation `method` is `"value"`.
        ///
        /// The data field to populate pivoted fields. The aggregate values of this field become the
        /// values of the new pivoted fields.
        /// </summary>
        [JsonProperty("value", NullValueHandling = NullValueHandling.Ignore)]
        public object Value { get; set; }

        /// <summary>
        /// The definition of the fields in the join aggregate, and what calculations to use.
        /// </summary>
        [JsonProperty("joinaggregate", NullValueHandling = NullValueHandling.Ignore)]
        public List<JoinAggregateFieldDef> Joinaggregate { get; set; }

        /// <summary>
        /// The data field of the dependent variable to smooth.
        /// </summary>
        [JsonProperty("loess", NullValueHandling = NullValueHandling.Ignore)]
        public string Loess { get; set; }

        /// <summary>
        /// The data field of the independent variable to use a predictor.
        /// </summary>
        [JsonProperty("on", NullValueHandling = NullValueHandling.Ignore)]
        public string On { get; set; }

        /// <summary>
        /// The default value to use if lookup fails.
        ///
        /// __Default value:__ `null`
        /// </summary>
        [JsonProperty("default", NullValueHandling = NullValueHandling.Ignore)]
        public string Default { get; set; }

        /// <summary>
        /// DataSource source or selection for secondary data reference.
        /// </summary>
        [JsonProperty("from", NullValueHandling = NullValueHandling.Ignore)]
        public Lookup From { get; set; }

        /// <summary>
        /// Key in primary data source.
        /// </summary>
        [JsonProperty("lookup", NullValueHandling = NullValueHandling.Ignore)]
        public string Lookup { get; set; }

        /// <summary>
        /// An array of probabilities in the range (0, 1) for which to compute quantile values. If
        /// not specified, the *step* parameter will be used.
        /// </summary>
        [JsonProperty("probs", NullValueHandling = NullValueHandling.Ignore)]
        public List<double> Probs { get; set; }

        /// <summary>
        /// The data field for which to perform quantile estimation.
        /// </summary>
        [JsonProperty("quantile", NullValueHandling = NullValueHandling.Ignore)]
        public string Quantile { get; set; }

        /// <summary>
        /// A probability step size (default 0.01) for sampling quantile values. All values from
        /// one-half the step size up to 1 (exclusive) will be sampled. This parameter is only used
        /// if the *probs* parameter is not provided.
        /// </summary>
        [JsonProperty("step", NullValueHandling = NullValueHandling.Ignore)]
        public double? Step { get; set; }

        /// <summary>
        /// The polynomial order (number of coefficients) for the 'poly' method.
        ///
        /// __Default value:__ `3`
        /// </summary>
        [JsonProperty("order", NullValueHandling = NullValueHandling.Ignore)]
        public double? Order { get; set; }

        /// <summary>
        /// A boolean flag indicating if the transform should return the regression model parameters
        /// (one object per group), rather than trend line points.
        /// The resulting objects include a `coef` array of fitted coefficient values (starting with
        /// the intercept term and then including terms of increasing order)
        /// and an `rSquared` value (indicating the total variance explained by the model).
        ///
        /// __Default value:__ `false`
        /// </summary>
        [JsonProperty("params", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Params { get; set; }

        /// <summary>
        /// The data field of the dependent variable to predict.
        /// </summary>
        [JsonProperty("regression", NullValueHandling = NullValueHandling.Ignore)]
        public string Regression { get; set; }

        /// <summary>
        /// The timeUnit.
        /// </summary>
        [JsonProperty("timeUnit", NullValueHandling = NullValueHandling.Ignore)]
        public TimeUnit? TimeUnit { get; set; }

        /// <summary>
        /// The maximum number of data objects to include in the sample.
        ///
        /// __Default value:__ `1000`
        /// </summary>
        [JsonProperty("sample", NullValueHandling = NullValueHandling.Ignore)]
        public double? Sample { get; set; }

        /// <summary>
        /// Mode for stacking marks. One of `"zero"` (default), `"center"`, or `"normalize"`.
        /// The `"zero"` offset will stack starting at `0`. The `"center"` offset will center the
        /// stacks. The `"normalize"` offset will compute percentage values for each stack point,
        /// with output values in the range `[0,1]`.
        ///
        /// __Default value:__ `"zero"`
        /// </summary>
        [JsonProperty("offset", NullValueHandling = NullValueHandling.Ignore)]
        public StackOffset? Offset { get; set; }

        /// <summary>
        /// Field that determines the order of leaves in the stacked charts.
        ///
        /// A sort field definition for sorting data objects within a window. If two data objects are
        /// considered equal by the comparator, they are considered "peer" values of equal rank. If
        /// sort is not specified, the order is undefined: data objects are processed in the order
        /// they are observed and none are considered peers (the ignorePeers parameter is ignored and
        /// treated as if set to `true`).
        /// </summary>
        [JsonProperty("sort", NullValueHandling = NullValueHandling.Ignore)]
        public List<SortField> Sort { get; set; }

        /// <summary>
        /// The field which is stacked.
        /// </summary>
        [JsonProperty("stack", NullValueHandling = NullValueHandling.Ignore)]
        public string Stack { get; set; }

        /// <summary>
        /// Indicates if the sliding window frame should ignore peer values (data that are considered
        /// identical by the sort criteria). The default is false, causing the window frame to expand
        /// to include all peer values. If set to true, the window frame will be defined by offset
        /// values only. This setting only affects those operations that depend on the window frame,
        /// namely aggregation operations and the first_value, last_value, and nth_value window
        /// operations.
        ///
        /// __Default value:__ `false`
        /// </summary>
        [JsonProperty("ignorePeers", NullValueHandling = NullValueHandling.Ignore)]
        public bool? IgnorePeers { get; set; }

        /// <summary>
        /// The definition of the fields in the window, and what calculations to use.
        /// </summary>
        [JsonProperty("window", NullValueHandling = NullValueHandling.Ignore)]
        public List<WindowFieldDef> Window { get; set; }

        /// <summary>
        /// An optional parameter indicating the maximum number of pivoted fields to generate.
        /// The default (`0`) applies no limit. The pivoted `pivot` names are sorted in ascending
        /// order prior to enforcing the limit.
        /// __Default value:__ `0`
        /// </summary>
        [JsonProperty("limit", NullValueHandling = NullValueHandling.Ignore)]
        public double? Limit { get; set; }

        /// <summary>
        /// The aggregation operation to apply to grouped `value` field values.
        /// __Default value:__ `sum`
        /// </summary>
        [JsonProperty("op", NullValueHandling = NullValueHandling.Ignore)]
        public string Op { get; set; }

        /// <summary>
        /// The data field to pivot on. The unique values of this field become new field names in the
        /// output stream.
        /// </summary>
        [JsonProperty("pivot", NullValueHandling = NullValueHandling.Ignore)]
        public string Pivot { get; set; }
    }
}